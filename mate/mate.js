/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/dataSquare.ts":
/*!********************************!*\
  !*** ./src/core/dataSquare.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar DataSquare = /** @class */ (function () {\n    function DataSquare(col, row, piece) {\n        this.col = col;\n        this.row = row;\n        this.piece = piece;\n    }\n    DataSquare.prototype.isEqual = function (square) {\n        if (!(square instanceof DataSquare))\n            return false;\n        return square.col == this.col && square.row == this.row;\n    };\n    ;\n    return DataSquare;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataSquare);\n\n\n//# sourceURL=webpack://chessboard/./src/core/dataSquare.ts?");

/***/ }),

/***/ "./src/core/piece.ts":
/*!***************************!*\
  !*** ./src/core/piece.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Piece = /** @class */ (function () {\n    function Piece(isWhite) {\n        this.className;\n        this.isWhite = isWhite;\n        this.chessboard = null;\n        this.wasMoved = false;\n        this.row = undefined;\n        this.col = undefined;\n    }\n    Piece.prototype.copyBase = function (piece) {\n        piece.className = this.className;\n        piece.isWhite = this.isWhite;\n        piece.chessboard = this.chessboard;\n        piece.wasMoved = this.wasMoved;\n        piece.row = this.row;\n        piece.col = this.col;\n    };\n    Piece.prototype.isValidMove = function (origSquare, destSquare) {\n        var moves = this.getPossibleMoves();\n        var found = false;\n        var destRow = destSquare.row;\n        var destCol = destSquare.col;\n        for (var i = 0; i < moves.length && !found; i++) {\n            var move = moves[i];\n            if (move.row == destRow && move.col == destCol)\n                found = true;\n        }\n        return found;\n    };\n    Piece.prototype.isAttackingSquare = function (row, col) {\n        var squares = this.getAttackedSquares();\n        for (var i = 0; i < squares.length; i++)\n            if (squares[i].col == col && squares[i].row == row)\n                return true;\n        return false;\n    };\n    Piece.prototype.getAttackedSquares = function () {\n        return [];\n    };\n    Piece.prototype.getPossibleMoves = function () {\n        return [];\n    };\n    Piece.prototype.isPossibleToMoveTo = function (col, row) {\n        var moves = this.getPossibleMoves();\n        for (var i = 0; i < moves.length; i++)\n            if (moves[i].col == col && moves[i].row == row)\n                return true;\n        return false;\n    };\n    Piece.prototype.getAttackedSquaresLine = function (targetCol, targetRow) {\n        return [];\n    };\n    Piece.prototype.removeSquaresWithSameColorPieces = function (squares) {\n        var filterSquaresWithPiecesSameColor = [];\n        for (var i = 0; i < squares.length; i++) {\n            var square = squares[i];\n            if (square.piece) {\n                if (square.piece.isWhite != this.isWhite) {\n                    filterSquaresWithPiecesSameColor.push(square);\n                }\n            }\n            else {\n                filterSquaresWithPiecesSameColor.push(square);\n            }\n        }\n        return filterSquaresWithPiecesSameColor;\n    };\n    Piece.prototype.getProtectedSquares = function () {\n        return [];\n    };\n    //should return true if the square is attacked by the piece, even if there are other pieces in the middle\n    Piece.prototype.isSquareOnXRay = function (row, col) {\n        return false;\n    };\n    return Piece;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Piece);\n\n\n//# sourceURL=webpack://chessboard/./src/core/piece.ts?");

/***/ }),

/***/ "./src/core/PieceFactory.js":
/*!**********************************!*\
  !*** ./src/core/PieceFactory.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PieceFactory)\n/* harmony export */ });\n/* harmony import */ var _pawn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pawn */ \"./src/core/pawn.js\");\n/* harmony import */ var _king__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./king */ \"./src/core/king.js\");\n/* harmony import */ var _knight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./knight */ \"./src/core/knight.js\");\n/* harmony import */ var _queen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./queen */ \"./src/core/queen.js\");\n/* harmony import */ var _rook__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rook */ \"./src/core/rook.js\");\n/* harmony import */ var _bishop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bishop */ \"./src/core/bishop.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass PieceFactory {\r\n    createDarkBishop  () {\r\n        return new _bishop__WEBPACK_IMPORTED_MODULE_5__[\"default\"](false);\r\n    }\r\n\r\n    createLightBishop  () {\r\n        return new _bishop__WEBPACK_IMPORTED_MODULE_5__[\"default\"](true);\r\n    }\r\n\r\n    createDarkRook  () {\r\n        return new _rook__WEBPACK_IMPORTED_MODULE_4__[\"default\"](false);\r\n    }\r\n\r\n    createLightRook  () {\r\n        return new _rook__WEBPACK_IMPORTED_MODULE_4__[\"default\"](true);\r\n    }\r\n\r\n    createDarkKight  () {\r\n        return new _knight__WEBPACK_IMPORTED_MODULE_2__[\"default\"](false);\r\n    }\r\n\r\n    createLightKight  () {\r\n        return new _knight__WEBPACK_IMPORTED_MODULE_2__[\"default\"](true);\r\n    }\r\n\r\n    createDarkQueen  () {\r\n        return new _queen__WEBPACK_IMPORTED_MODULE_3__[\"default\"](false);\r\n    }\r\n\r\n    createLightQueen  () {\r\n        return new _queen__WEBPACK_IMPORTED_MODULE_3__[\"default\"](true);\r\n    }\r\n\r\n    createDarkKing  () {\r\n        return new _king__WEBPACK_IMPORTED_MODULE_1__[\"default\"](false);\r\n    }\r\n\r\n    createLightKing  () {\r\n        return new _king__WEBPACK_IMPORTED_MODULE_1__[\"default\"](true);\r\n    }\r\n\r\n    createDarkPawn  () {\r\n        return new _pawn__WEBPACK_IMPORTED_MODULE_0__[\"default\"](false);\r\n    }\r\n\r\n    createLightPawn  () {\r\n        return new _pawn__WEBPACK_IMPORTED_MODULE_0__[\"default\"](true);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://chessboard/./src/core/PieceFactory.js?");

/***/ }),

/***/ "./src/core/bishop.js":
/*!****************************!*\
  !*** ./src/core/bishop.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Bishop)\n/* harmony export */ });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/core/piece.ts\");\n/* harmony import */ var _pieces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieces */ \"./src/core/pieces.js\");\n\r\n\r\nclass Bishop extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"]{\r\n    constructor(isWhite)\r\n    {\r\n        super(isWhite)\r\n        this.className = (isWhite) ? _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].L_BISHOP : _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].D_BISHOP;\r\n    }\r\n\r\n    copy()\r\n    {\r\n        var newBishop = new Bishop(this.isWhite);\r\n        this.copyBase(newBishop);\r\n\r\n        return newBishop;\r\n    }\r\n\r\n    getAttackedSquares() {\r\n        var protectedSquares = this.getProtectedSquares();\r\n        var squares = this.removeSquaresWithSameColorPieces(protectedSquares);\r\n\r\n        return squares;\r\n    }\r\n\r\n    getProtectedSquares(){\r\n        var chessboard = this.chessboard;\r\n        var icol = this.col + 1;\r\n        var irow = this.row + 1;\r\n        var mrow = chessboard.getMaxCol();\r\n        var mcol = chessboard.getMaxRow();\r\n        var limit = false;\r\n        var squares = [];\r\n\r\n        while (icol <= mcol && irow <= mrow && limit == false) {\r\n            limit = this.addSquare(irow, icol, chessboard, squares);\r\n\r\n            irow++;\r\n            icol++;\r\n        }\r\n\r\n        limit = false;\r\n        icol = this.col - 1;\r\n        irow = this.row + 1;\r\n\r\n        while (icol >= 0 && irow <= mrow && limit == false) {\r\n            limit = this.addSquare(irow, icol, chessboard, squares);\r\n            icol--;\r\n            irow++;\r\n        }\r\n\r\n        limit = false;\r\n        icol = this.col - 1;\r\n        irow = this.row - 1;\r\n\r\n        while (icol >= 0 && irow >= 0 && limit == false) {\r\n            limit = this.addSquare(irow, icol, chessboard, squares);\r\n            icol--;\r\n            irow--;\r\n        }\r\n\r\n        limit = false;\r\n        icol = this.col + 1;\r\n        irow = this.row - 1;\r\n\r\n        while (icol <= mcol && irow >= 0 && limit == false) {\r\n            limit = this.addSquare(irow, icol, chessboard, squares);\r\n\r\n            icol++;\r\n            irow--;\r\n        }\r\n\r\n        return squares;\r\n    }\r\n\r\n    getPossibleMoves() {\r\n        return this.getAttackedSquares();\r\n    }\r\n\r\n    getAttackedSquaresLine(targetCol, targetRow) {\r\n        //This function returns all the squares attacked that are aligned with the target square (they are in the same bishop diagonal) \r\n        var line = [];\r\n        var moves = this.getPossibleMoves();\r\n\r\n        for (var i = 0; i < moves.length; i++) {\r\n            var difrows = Math.abs(moves[i].row - targetRow);\r\n            var difcols = Math.abs(moves[i].col - targetCol);\r\n\r\n            if (difrows == difcols)//if number of cols and rows are the same, it means they are in the same diagonal\r\n                line.push(moves[i]);\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n   \r\n\r\n    addSquare(row, col, chessboard, squares) {\r\n        var limit = false;\r\n\r\n        var square = chessboard.getSquare(row, col);\r\n\r\n        if (square.piece) {\r\n            limit = true;\r\n\r\n            //if (square.piece.isWhite != this.isWhite)\r\n                squares.push(square);\r\n        }\r\n        else {\r\n            squares.push(square);\r\n        }\r\n\r\n        return limit;\r\n    }\r\n\r\n    //should return true if the square is attacked by the piece, even if there are other pieces in the middle\r\n    isSquareOnXRay(row, col){\r\n        let diffy = Math.abs(this.row - row);\r\n        let diffx = Math.abs(this.col - col);\r\n        let isBishopSquare = diffy === diffx;\r\n        return isBishopSquare;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://chessboard/./src/core/bishop.js?");

/***/ }),

/***/ "./src/core/board.js":
/*!***************************!*\
  !*** ./src/core/board.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChessBoard)\n/* harmony export */ });\n/* harmony import */ var _king__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./king */ \"./src/core/king.js\");\n/* harmony import */ var _rook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rook */ \"./src/core/rook.js\");\n/* harmony import */ var _dataSquare__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dataSquare */ \"./src/core/dataSquare.ts\");\n/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./square */ \"./src/core/square.js\");\n\r\n\r\n\r\n\r\n\r\nclass ChessBoard {\r\n  constructor()\r\n  {\r\n    this.MAX_COL = 7;\r\n    this.MAX_ROW = 7;\r\n    this.isWhiteTurn = true;\r\n    this.squares = [];\r\n    this.onAfterMove = null;\r\n    this._init();\r\n  }\r\n\r\n  _init () {\r\n    this._createBoard();\r\n  };\r\n\r\n  _createBoard () {\r\n    this.squares = [];\r\n\r\n    for (var i = 0; i < 8; i++) {\r\n      var row = [];\r\n      this.squares.push(row);\r\n\r\n      for (var j = 0; j < 8; j++) {\r\n        row.push(new _square__WEBPACK_IMPORTED_MODULE_3__[\"default\"]());\r\n      }\r\n    }\r\n  };\r\n\r\n  clear(){\r\n    this.squares = [];\r\n    this._createBoard();\r\n  }\r\n\r\n  setBlackTurn(){\r\n    this.isWhiteTurn = false;\r\n  }\r\n\r\n  setWhiteTurn(){\r\n    this.isWhiteTurn = true;\r\n  }\r\n\r\n  copy()\r\n  {\r\n    var newBoard = new ChessBoard();\r\n    newBoard.isWhiteTurn = this.isWhiteTurn;\r\n    newBoard.onAfterMove = this.onAfterMove;\r\n\r\n    for(var i = 0; i < 8; i++)\r\n    {\r\n      for(var j = 0; j < 8; j++){\r\n        var newSquare = this.squares[i][j].copy();\r\n        newBoard.squares[i][j] = newSquare;\r\n\r\n        if(newSquare.piece){\r\n          newSquare.piece.chessboard = newBoard;\r\n        }\r\n      }\r\n    }\r\n\r\n    return newBoard;\r\n  }\r\n\r\n  addPiece (squareStrings, piece) {\r\n    var square = this.convertSquareString(squareStrings);\r\n\r\n    var row = square.row;\r\n    var col = square.col;\r\n\r\n    if (row > 8 || row < 0) return;\r\n\r\n    if (col > 8 || col < 0) return;\r\n\r\n    var square = this.squares[row][col];\r\n\r\n    if (piece) {\r\n      square.piece = piece;\r\n      piece.col = col;\r\n      piece.row = row;\r\n      piece.chessboard = this;\r\n    }\r\n  };\r\n\r\n  getPiece (row, col) {\r\n    if (typeof row == \"string\") {\r\n      var square = this.convertSquareString(row);\r\n\r\n      if (square) {\r\n        row = square.row;\r\n        col = square.col;\r\n      }\r\n    }\r\n\r\n    var piece = this.squares[row][col];\r\n    piece = piece == undefined ? null : piece.piece;\r\n\r\n    return piece;\r\n  };\r\n\r\n  getSquare (row, col) {\r\n    if(typeof row == \"string\"){\r\n      var square = this.convertSquareString(row);\r\n\r\n      if(square){\r\n        row = square.row;\r\n        col = square.col;\r\n      }\r\n\r\n    }\r\n    if (!this.squares[row]) return;\r\n\r\n    if (!this.squares[row][col]) return null;\r\n\r\n    var piece = this.squares[row][col].piece;\r\n    var dataSquare = new _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"](col, row, piece);\r\n\r\n    return dataSquare;\r\n  };\r\n\r\n  _internalMove (from, to) {\r\n    var fromSquare =\r\n      from instanceof _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? from : this.convertSquareString(from);\r\n    var toSquare = to instanceof _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? to : this.convertSquareString(to);\r\n\r\n    if (fromSquare == null && toSquare != null) throw \"invalid move\";\r\n\r\n    var square = this.squares[fromSquare.row][fromSquare.col];\r\n    var destSquare = this.squares[toSquare.row][toSquare.col];\r\n\r\n    if (\r\n      square == null ||\r\n      square == undefined ||\r\n      destSquare == null ||\r\n      destSquare == undefined\r\n    )\r\n      throw \"invalid square\";\r\n\r\n    if (square.piece == null || square.piece == undefined)\r\n      throw \"no piece to move\";\r\n\r\n    var piece = square.piece;\r\n\r\n    square.piece = null;\r\n    piece.wasMoved = true;\r\n    destSquare.piece = piece;\r\n\r\n    piece.col = toSquare.col;\r\n    piece.row = toSquare.row;\r\n  };\r\n\r\n  move (from, to) {\r\n    var fromSquare = from instanceof _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? from : this.convertSquareString(from);\r\n    var toSquare = to instanceof _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? to : this.convertSquareString(to);\r\n\r\n    if (fromSquare == null && toSquare != null)\r\n      throw \"invalid move\";\r\n\r\n    if(this._isCastle(fromSquare, toSquare))\r\n    {\r\n      //make king move\r\n      this._internalMove(from, to);\r\n\r\n      //make rook move\r\n      var rookCol = toSquare.col == 6? 7 : 0;\r\n      var rookDestCol = toSquare.col == 6? 5: 3;\r\n      var rookSquare = this.getSquare(fromSquare.row, rookCol); \r\n      var rookDestSquare = this.getSquare(fromSquare.row, rookDestCol);\r\n\r\n      if(rookSquare.piece instanceof _rook__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\r\n      {\r\n        this._internalMove(rookSquare, rookDestSquare);\r\n      }\r\n\r\n    }\r\n    else\r\n    {\r\n      this._internalMove(from, to);\r\n    }\r\n\r\n    \r\n    this.isWhiteTurn = !this.isWhiteTurn;\r\n\r\n    if (this.onAfterMove instanceof Function) this.onAfterMove();\r\n  };\r\n\r\n  \r\n\r\n  isCheck (isWhite) {\r\n    if(isWhite === undefined)\r\n      isWhite = this.isWhiteTurn;\r\n    \r\n    var myPieces = this.getPieces(isWhite);\r\n    var enemyPieces = this.getPieces(!isWhite);\r\n    var myKing = this._findKing(myPieces);\r\n\r\n    var isCheck = this._isPieceAttackingKing(myKing, enemyPieces);\r\n\r\n    return isCheck;\r\n  };\r\n\r\n  isCheckMate () {\r\n    /* 0) is check\r\n        1) king can't scape\r\n        2) can't capture the atacking piece\r\n        3) can't place a piece between the atacking piece and the king  */\r\n\r\n    if (!this.isCheck(this.isWhiteTurn)) return false;\r\n\r\n    //1) king cant scape\r\n    var myPieces = this.getPieces(this.isWhiteTurn);\r\n    var king = this._findKing(myPieces);\r\n    var kingPossibleMoves = king.getPossibleMoves();\r\n\r\n    if (kingPossibleMoves.length > 0) return false;\r\n\r\n    //2) can't capture the attacking piece\r\n    var enemyPieces = this.getPieces(!this.isWhiteTurn);\r\n    var piecesAttackingKing = [];\r\n\r\n    //first i get the pieces attacking the king\r\n    for (var i = 0; i < enemyPieces.length; i++)\r\n      if (enemyPieces[i].isAttackingSquare(king.row, king.col))\r\n        piecesAttackingKing.push(enemyPieces[i]);\r\n\r\n    if (piecesAttackingKing.length == 1) {\r\n      var attacker = piecesAttackingKing[0];\r\n      //i can capture only one piece in my turn\r\n      for (var i = 0; i < myPieces.length; i++) {\r\n        var piece = myPieces[i];\r\n\r\n        if (piece.isAttackingSquare(attacker.row, attacker.col)) {\r\n          var from = this.convertPositionToString(piece.col, piece.row);\r\n          var to = this.convertPositionToString(attacker.col, attacker.row);\r\n\r\n          if (this.isValidMove(from, to))//i can capture. It is not checkmate\r\n            return false;\r\n\r\n        }\r\n      }\r\n    }\r\n\r\n    //3)can't place a piece between the atacking piece and the king\r\n    for (var i = 0; i < piecesAttackingKing.length; i++) {\r\n      var attackingLine = piecesAttackingKing[i].getAttackedSquaresLine(king.col, king.row);\r\n\r\n      for (var j = 0; j < myPieces.length; j++) {\r\n        var myPiece = myPieces[j];\r\n\r\n        if (!(myPiece instanceof _king__WEBPACK_IMPORTED_MODULE_0__[\"default\"])) //skip king\r\n        {\r\n          for (var k = 0; k < attackingLine.length; k++) {\r\n            var lineSquare = attackingLine[k];\r\n            if (myPiece.isPossibleToMoveTo(lineSquare.col, lineSquare.row)) {\r\n              var from = this.convertPositionToString(myPiece.col, myPiece.row);\r\n              var col = this.convertPositionToString(lineSquare.col, lineSquare.row);\r\n\r\n              if (this.isValidMove(from, col))\r\n                return false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  _getKing (isWhite) {\r\n    var pieces = this.getPieces(isWhite);\r\n    var king = null;\r\n\r\n    this.forEachPiece((e) => {\r\n      if (e instanceof _king__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) king = e;\r\n    });\r\n\r\n    return king;\r\n  };\r\n\r\n  _isPieceAttackingKing (king, pieces) {\r\n    var isCheck = false;\r\n\r\n    for (var i = 0; i < pieces.length && !isCheck; i++) {\r\n      var squares = pieces[i].getAttackedSquares();\r\n\r\n      for (var s = 0; s < squares.length && !isCheck; s++) {\r\n        var square = squares[s];\r\n\r\n        if (square.col == king.col && square.row == king.row) isCheck = true;\r\n      }\r\n    }\r\n    return isCheck;\r\n  };\r\n\r\n  _findKing (pieces) {\r\n    var king = null;\r\n\r\n    for (var i = 0; i < pieces.length; i++) {\r\n      if (pieces[i] instanceof _king__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\r\n        king = pieces[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    return king;\r\n  };\r\n\r\n  getBlackPieces () {\r\n    return this.getPieces(false);\r\n  };\r\n\r\n  getWhitePieces () {\r\n    return this.getPieces(true);\r\n  };\r\n\r\n  getPieces (isWhite) {\r\n    var pieces = [];\r\n\r\n    this.forEachPiece(function (piece) {\r\n      if (piece.isWhite == isWhite) {\r\n        pieces.push(piece);\r\n      }\r\n    });\r\n\r\n    return pieces;\r\n  };\r\n\r\n  _isCastle (fromSquare, toSquare) {\r\n    var squareOrig = this.squares[fromSquare.row][fromSquare.col];\r\n\r\n    if (squareOrig.piece == null || !(squareOrig.piece instanceof _king__WEBPACK_IMPORTED_MODULE_0__[\"default\"]))\r\n      return false;\r\n\r\n    var isFirstRank = fromSquare.row == toSquare.row && toSquare.row == 0 || toSquare.row == 7;\r\n    var isCastleColumn = toSquare.col == 6 || toSquare.col == 2;\r\n    var isKingOriginalPosition = fromSquare.col == 4;\r\n\r\n    return isFirstRank && isKingOriginalPosition && isCastleColumn;\r\n  }\r\n\r\n  isValidMove (from, to) {\r\n    var fromSquare = null;\r\n    var toSquare = null;\r\n\r\n    if (from instanceof _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\r\n      fromSquare = { col: from.col, row: from.row };\r\n    else fromSquare = this.convertSquareString(from);\r\n\r\n    if (to instanceof _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) toSquare = { col: to.col, row: to.row };\r\n    else toSquare = this.convertSquareString(to);\r\n\r\n    if (fromSquare == null) return false;\r\n\r\n    var pieceOrig = this.squares[fromSquare.row][fromSquare.col];\r\n    var pieceDest = this.squares[toSquare.row][toSquare.col];\r\n\r\n    if (pieceOrig == null) return false;\r\n\r\n    if (pieceOrig.piece == null) return false;\r\n\r\n    //we cant move if is not our turn\r\n    if (pieceOrig.piece != null && pieceOrig.piece.isWhite != this.isWhiteTurn)\r\n      return false;\r\n\r\n    //we cant take a piece of the same colour\r\n    if (\r\n      pieceDest.piece != null &&\r\n      pieceDest.piece.isWhite == pieceOrig.piece.isWhite\r\n    )\r\n      return false;\r\n\r\n    var pieceMovedColor = pieceOrig.piece.isWhite;\r\n\r\n    var dataOrig = new _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\r\n      fromSquare.col,\r\n      fromSquare.row,\r\n      pieceOrig ? pieceOrig.piece : null\r\n    );\r\n    var dataDest = new _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\r\n      toSquare.col,\r\n      toSquare.row,\r\n      pieceDest ? pieceDest.piece : null\r\n    );\r\n\r\n    var validMove = pieceOrig.piece.isValidMove(dataOrig, dataDest, this);\r\n\r\n    if (validMove) {\r\n      var backupPiece = pieceDest.piece;\r\n      this._internalMove(from, to);\r\n\r\n      if (this.isCheck(pieceMovedColor)) {\r\n        //cant move because is check\r\n        validMove = false;\r\n      }\r\n\r\n      this._internalMove(to, from); //restore movement\r\n\r\n      //this is to recover the piece, if there was any in the \"to\" square\r\n      if (backupPiece != null)\r\n        this.squares[toSquare.row][toSquare.col].piece = backupPiece;\r\n    }\r\n\r\n    return validMove;\r\n  };\r\n\r\n  forEachPiece (callback) {\r\n    if (!(callback instanceof Function)) return;\r\n\r\n    for (var i = 0; i < 8; i++) {\r\n      for (var j = 0; j < 8; j++) {\r\n        var square = this.getSquare(i, j);\r\n        var piece = square.piece;\r\n\r\n        if (piece != null) callback(piece);\r\n      }\r\n    }\r\n  };\r\n\r\n  getSquaresProtectedBy(protectedByWhite) {\r\n    protectedByWhite = protectedByWhite === undefined ? true : protectedByWhite;\r\n    var squares = [];\r\n\r\n    this.forEachPiece((piece) => {\r\n      if (piece.isWhite == protectedByWhite) {\r\n        var sqs = piece.getProtectedSquares(this);\r\n        sqs.forEach((e) => {\r\n          squares.push(e);\r\n        });\r\n      }\r\n    });\r\n\r\n    return squares;\r\n  }\r\n\r\n  getSquaresAttackedBy (attackedByWhite) {\r\n    attackedByWhite = attackedByWhite === undefined ? true : attackedByWhite;\r\n    var squares = [];\r\n\r\n    this.forEachPiece((piece) => {\r\n      if (piece.isWhite == attackedByWhite) {\r\n        var sqs = piece.getAttackedSquares(this);\r\n        sqs.forEach((e) => {\r\n          squares.push(e);\r\n        });\r\n      }\r\n    });\r\n\r\n    return squares;\r\n  };\r\n\r\n  getMoves()\r\n  {\r\n    return this._getValidMoves();\r\n  }\r\n\r\n  _getValidMoves(){\r\n    var moves = this._getMoves();\r\n    var validMoves = [];\r\n\r\n    moves.forEach(e => {\r\n      if (this.isValidMove(e.squareFrom, e.squareTo))\r\n        validMoves.push(e);\r\n    });\r\n\r\n    return validMoves;\r\n  }\r\n\r\n  _getMoves() {\r\n    var pieces = this.getPieces(this.isWhiteTurn);\r\n    var listOfMoves = [];\r\n\r\n    for (var i = 0; i < pieces.length; i++) {\r\n      var piece = pieces[i];\r\n      var moves = piece.getPossibleMoves();\r\n\r\n      for (var j = 0; j < moves.length; j++) {\r\n        var squareFrom = new _dataSquare__WEBPACK_IMPORTED_MODULE_2__[\"default\"](piece.col, piece.row);\r\n        var squareTo = moves[j];\r\n        listOfMoves.push(new PieceMove(squareFrom, squareTo));\r\n      }\r\n    }\r\n\r\n    return listOfMoves;\r\n  }\r\n\r\n  convertPositionToString(col, row) {\r\n    var cols = {\r\n      0: \"a\",\r\n      1: \"b\",\r\n      2: \"c\",\r\n      3: \"d\",\r\n      4: \"e\",\r\n      5: \"f\",\r\n      6: \"g\",\r\n      7: \"h\",\r\n    };\r\n\r\n    var rows = {\r\n      7: \"8\",\r\n      6: \"7\",\r\n      5: \"6\",\r\n      4: \"5\",\r\n      3: \"4\",\r\n      2: \"3\",\r\n      1: \"2\",\r\n      0: \"1\",\r\n    };\r\n\r\n    var res = null;\r\n\r\n    if (cols[col] != undefined && rows[row] != undefined) {\r\n      res = cols[col] + rows[row];\r\n    }\r\n\r\n    return res;\r\n  };\r\n\r\n  getMaxCol() {\r\n    return this.MAX_COL;\r\n  };\r\n\r\n  getMaxRow() {\r\n    return this.MAX_ROW;\r\n  };\r\n\r\n  convertSquareString(square) {\r\n    var cols = {\r\n      a: 0,\r\n      b: 1,\r\n      c: 2,\r\n      d: 3,\r\n      e: 4,\r\n      f: 5,\r\n      g: 6,\r\n      h: 7,\r\n    };\r\n\r\n    var rows = {\r\n      8: 7,\r\n      7: 6,\r\n      6: 5,\r\n      5: 4,\r\n      4: 3,\r\n      3: 2,\r\n      2: 1,\r\n      1: 0,\r\n    };\r\n\r\n    if (square.length != 2) return null;\r\n\r\n    var col = cols[square.charAt(0)];\r\n    var row = rows[square.charAt(1)];\r\n\r\n    if (col == undefined || row == undefined) return null;\r\n\r\n    return { col: col, row: row };\r\n  };\r\n\r\n}\r\n\r\n\r\nfunction PieceMove(squareFrom, squareTo)\r\n{\r\n    this.squareFrom = squareFrom;\r\n    this.squareTo = squareTo;\r\n}\r\n\n\n//# sourceURL=webpack://chessboard/./src/core/board.js?");

/***/ }),

/***/ "./src/core/computer.js":
/*!******************************!*\
  !*** ./src/core/computer.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckMate: () => (/* binding */ CheckMate),\n/* harmony export */   \"default\": () => (/* binding */ Computer)\n/* harmony export */ });\n/* harmony import */ var _dataSquare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataSquare */ \"./src/core/dataSquare.ts\");\n\r\nfunction Computer(chessboard)\r\n{\r\n    var self = this;\r\n    this.isWhite = false;\r\n    this.chessboard = chessboard;\r\n\r\n    this.move = function()\r\n    {\r\n        if(!self._isMyTurn())\r\n            return;\r\n\r\n        var moves = self._getValidMoves();\r\n\r\n        if(moves.length == 0)\r\n            return;\r\n\r\n        var index = Math.floor(Math.random() * moves.length);\r\n        //var index = moves.length - 1;\r\n        var move = moves[index];\r\n\r\n        chessboard.move(move.squareFrom, move.squareTo);\r\n    }\r\n\r\n    this.findCheckMate = function()\r\n    {\r\n        var finder = new CheckMate();\r\n        var moves = finder.find(this.chessboard);\r\n        return moves;\r\n    }\r\n\r\n    this._getValidMoves = function()\r\n    {\r\n        var moves = this._getMoves();\r\n        var validMoves = [];\r\n\r\n        moves.forEach(e => {\r\n            if(chessboard.isValidMove(e.squareFrom, e.squareTo))\r\n                validMoves.push(e);\r\n        });\r\n\r\n        return validMoves;\r\n    }\r\n\r\n    this._getMoves = function()\r\n    {\r\n        var pieces = chessboard.getPieces(self.isWhite);\r\n        var listOfMoves = [];\r\n\r\n        for(var i = 0; i < pieces.length; i++)\r\n        {\r\n            var piece = pieces[i];\r\n            var moves = piece.getPossibleMoves();\r\n\r\n            for(var j = 0; j < moves.length; j++)\r\n            {\r\n                var squareFrom = new _dataSquare__WEBPACK_IMPORTED_MODULE_0__[\"default\"](piece.col, piece.row);\r\n                var squareTo = moves[j];\r\n                listOfMoves.push(new PieceMove(squareFrom, squareTo));\r\n            }\r\n        }\r\n\r\n        return listOfMoves;\r\n    }\r\n\r\n    this._isMyTurn = function()\r\n    {\r\n        return self.isWhite == chessboard.isWhiteTurn;\r\n    }\r\n}\r\n\r\n\r\n/* class CheckMate\r\n{\r\n    find(chessboard)\r\n    {\r\n        var moves = [];\r\n        moves = this._find(chessboard, moves);\r\n        return moves;\r\n    }\r\n\r\n    _find(chessboard, moves)\r\n    {\r\n        if(chessboard.isCheckMate())\r\n            return moves;\r\n        \r\n        var solutionMoves = null;\r\n\r\n        for(var i = 0; i < moves.length; i++)\r\n        {\r\n            var move = moves[i];\r\n            var newMoves = [...moves, move];\r\n            var boardCopy = chessboard.copy();\r\n\r\n            boardCopy.move(move.squareFrom, move.squareTo);\r\n            newMoves = this._find(boardCopy, newMoves);\r\n\r\n            if(newMoves != null)//its checkmate using the new move\r\n            {\r\n                if(solutionMoves == null)\r\n                    solutionMoves = newMoves;\r\n                else if(newMoves.length < solutionMoves.length)//keep the solution with less moves\r\n                    solutionMoves = newMoves;\r\n            }\r\n\r\n            boardCopy = null;\r\n        }\r\n\r\n        return solutionMoves;\r\n    }\r\n} */\r\n\r\nclass CheckMate\r\n{\r\n    MAX_DEPTH = 10;\r\n\r\n    search(chessboard, depth, current_moves)\r\n    {\r\n        if(depth === undefined)\r\n            depth = 1;\r\n        \r\n        if(current_moves === undefined)\r\n            current_moves = [];\r\n\r\n        if(chessboard.isCheckMate())\r\n            return current_moves;\r\n\r\n        if(depth == this.MAX_DEPTH)\r\n            return null;//not found\r\n\r\n\r\n        var moves = chessboard.getMoves();\r\n\r\n        for(var i = 0; i < moves.length; i++)\r\n        {\r\n            var move = moves[i];\r\n\r\n            var copy = chessboard.copy();\r\n            copy.move(move.squareFrom, move.squareTo);\r\n\r\n            var variation_moves = [...current_moves, move];\r\n            var solution = this.search(copy, depth + 1, variation_moves);\r\n\r\n            if(solution != null){\r\n                return solution;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n} \r\n/*\r\nfunction PieceMove(squareFrom, squareTo)\r\n{\r\n    this.squareFrom = squareFrom;\r\n    this.squareTo = squareTo;\r\n}*/\r\n\r\nfunction PieceMove(squareFrom, squareTo)\r\n{\r\n    this.squareFrom = squareFrom;\r\n    this.squareTo = squareTo;\r\n}\n\n//# sourceURL=webpack://chessboard/./src/core/computer.js?");

/***/ }),

/***/ "./src/core/king.js":
/*!**************************!*\
  !*** ./src/core/king.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ King)\n/* harmony export */ });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/core/piece.ts\");\n/* harmony import */ var _pieces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieces */ \"./src/core/pieces.js\");\n/* harmony import */ var _rook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rook */ \"./src/core/rook.js\");\n\r\n\r\n\r\n\r\n\r\nclass King extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(isWhite) {\r\n        super(isWhite);\r\n        this.className = (isWhite) ? _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].L_KING : _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].D_KING;\r\n    }\r\n\r\n    copy()\r\n    {\r\n        var newPiece = new King(this.isWhite);\r\n        this.copyBase(newPiece);\r\n\r\n        return newPiece;\r\n    }\r\n\r\n    getAttackedSquares() {\r\n        var protectedSquares = this.getProtectedSquares();\r\n        var squares = this.removeSquaresWithSameColorPieces(protectedSquares);\r\n\r\n        return squares;\r\n    }\r\n\r\n    getProtectedSquares(){\r\n        var chessboard = this.chessboard;\r\n        var attacked = [];\r\n\r\n        attacked.push(chessboard.getSquare(this.row, this.col + 1));\r\n        attacked.push(chessboard.getSquare(this.row, this.col - 1));\r\n\r\n        attacked.push(chessboard.getSquare(this.row + 1, this.col));\r\n        attacked.push(chessboard.getSquare(this.row + 1, this.col + 1));\r\n        attacked.push(chessboard.getSquare(this.row + 1, this.col - 1));\r\n\r\n        attacked.push(chessboard.getSquare(this.row - 1, this.col));\r\n        attacked.push(chessboard.getSquare(this.row - 1, this.col + 1));\r\n        attacked.push(chessboard.getSquare(this.row - 1, this.col - 1));\r\n\r\n        var filtered = [];\r\n\r\n        attacked.forEach(e => {\r\n            if (e != null && e != undefined)\r\n                filtered.push(e);\r\n        });\r\n\r\n        return filtered;\r\n    }\r\n\r\n    getPossibleMoves() {\r\n        var chessboard = this.chessboard;\r\n        var attacked = this.getAttackedSquares();\r\n        var filtered = [];\r\n        var protectedByEnemy = chessboard.getSquaresProtectedBy(!this.isWhite);\r\n\r\n        attacked.forEach( (e)=> {\r\n\r\n            var sameColorPiece = (e.piece && e.piece.isWhite == this.isWhite);\r\n\r\n            if (e != null && !sameColorPiece) {\r\n                var isSquareAttacked = false;\r\n\r\n                for (var i = 0; i < protectedByEnemy.length && isSquareAttacked == false; i++) {\r\n                    var squaredAttacked = protectedByEnemy[i];\r\n\r\n                    if (e.isEqual(squaredAttacked))\r\n                        isSquareAttacked = true;\r\n                }\r\n\r\n                if (!isSquareAttacked)\r\n                    filtered.push(e);\r\n            }\r\n        });\r\n\r\n        //remove moves if the target square is on X ray with some piece\r\n        filtered = this._removeMovesIfSquareIsOnXRay(filtered);\r\n\r\n        var isCheck = this.chessboard.isCheck(this.isWhite);\r\n\r\n        if (!isCheck) //i cant castle in check\r\n        {\r\n            //add clastle\r\n            if (this.canShortCastle())\r\n                filtered.push(this.chessboard.getSquare(this.row, this.col + 2));\r\n\r\n            if (this.canLongCastle())\r\n                filtered.push(this.chessboard.getSquare(this.row, this.col - 2));\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    canShortCastle() {\r\n        // () Neither the king nor the chosen rook has previously moved.\r\n        // () There are no pieces between the king and the chosen rook.\r\n        // () The king is not currently in check.\r\n        // () The king does not pass through a square that is attacked by an enemy piece.\r\n        // () The king does not end up in check. (True of any legal move.)\r\n        if (this._wereKingOrRookMoved())\r\n            return false;\r\n\r\n        if (!this._isShortCastlePathFree())\r\n            return false;\r\n\r\n        var squaresKingGoesThrough = [];\r\n        squaresKingGoesThrough.push(this.chessboard.getSquare(this.row, this.col + 1));\r\n        squaresKingGoesThrough.push(this.chessboard.getSquare(this.row, this.col + 2));\r\n\r\n        if (this._areSquaresProtectedByEnemy(squaresKingGoesThrough))\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    canLongCastle() {\r\n        // () Neither the king nor the chosen rook has previously moved.\r\n        // () There are no pieces between the king and the chosen rook.\r\n        // () The king is not currently in check.\r\n        // () The king does not pass through a square that is attacked by an enemy piece.\r\n        // () The king does not end up in check. (True of any legal move.)\r\n        if (this._wereKingOrRookMoved())\r\n            return false;\r\n\r\n        if (!this._isLongCastlePathFree())\r\n            return false;\r\n\r\n        var squaresKingGoesThrough = [];\r\n        squaresKingGoesThrough.push(this.chessboard.getSquare(this.row, this.col - 1));\r\n        squaresKingGoesThrough.push(this.chessboard.getSquare(this.row, this.col - 2));\r\n\r\n        if (this._areSquaresProtectedByEnemy(squaresKingGoesThrough))\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    _areSquaresProtectedByEnemy(listSquares) {\r\n        var protectedByEnemy = this.chessboard.getSquaresProtectedBy(!this.isWhite);\r\n\r\n        for (var i = 0; i < protectedByEnemy.length; i++) {\r\n            var protectedSquare = protectedByEnemy[i];\r\n\r\n            for (var j = 0; j < listSquares.length; j++) {\r\n                var square = listSquares[j];\r\n\r\n                if (protectedSquare.row == square.row && protectedSquare.col == square.col)\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    _isShortCastlePathFree() {\r\n        var piece1 = this.chessboard.getPiece(this.row, this.col + 1);\r\n        var piece2 = this.chessboard.getPiece(this.row, this.col + 2);\r\n\r\n        //if there are no pieces in the right squares\r\n        return piece1 == null && piece2 == null;\r\n    }\r\n\r\n    _isLongCastlePathFree() {\r\n        var p1 = this.chessboard.getPiece(this.row, this.col - 1);\r\n        var p2 = this.chessboard.getPiece(this.row, this.col - 2)\r\n        var p3 = this.chessboard.getPiece(this.row, this.col - 3)\r\n\r\n        //if there are no pieces in the left squares\r\n        return p1 == null && p2 == null && p3 == null;\r\n    }\r\n\r\n    _wereKingOrRookMoved() {\r\n        //check rook and king were not moved\r\n        if (this.wasMoved)\r\n            return true;\r\n\r\n        var rook = this._getRook();\r\n\r\n        if (rook == null) //this means it was captured or does not exists, i can't castle\r\n            return true;\r\n\r\n        if (rook.wasMoved)\r\n            return true;\r\n\r\n        let originalPosition = this._getOriginalPosition();\r\n\r\n        if(originalPosition.row !== this.row || originalPosition.col !== this.col)\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    _getRook() {\r\n        var pieces = this.chessboard.getPieces(this.isWhite);\r\n        var rook = null;\r\n\r\n        for (var i = 0; i < pieces.length; i++)\r\n            if (pieces[i] instanceof _rook__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\r\n                rook = pieces[i];\r\n\r\n        return rook;\r\n    }\r\n\r\n    _removeMovesIfSquareIsOnXRay(moves){\r\n        var filtered = [];\r\n        var enemyPieces = this.chessboard.getPieces(!this.isWhite);\r\n\r\n        for(let j = 0; j < moves.length; j++){\r\n            let move = moves[j];\r\n            let isOnXRay = false;\r\n\r\n            for(let i = 0; i < enemyPieces.length && isOnXRay === false; i++){\r\n                let piece = enemyPieces[i];\r\n\r\n                if(piece.isSquareOnXRay(move.row, move.col)\r\n                    && piece.isSquareOnXRay(this.row, this.col)) //i also need to check king: I should remove posible square if the king moves to that square and is check\r\n                    isOnXRay = true;\r\n            }\r\n\r\n\r\n            if(!isOnXRay)\r\n                filtered.push(move);\r\n        }\r\n        \r\n        return filtered;\r\n    }\r\n\r\n    _getOriginalPosition(){\r\n        return this.isWhite?{col: 4, row : 0}: {col: 4, row: 7};\r\n    }\r\n}\n\n//# sourceURL=webpack://chessboard/./src/core/king.js?");

/***/ }),

/***/ "./src/core/knight.js":
/*!****************************!*\
  !*** ./src/core/knight.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Knight)\n/* harmony export */ });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/core/piece.ts\");\n/* harmony import */ var _pieces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieces */ \"./src/core/pieces.js\");\n\r\n\r\n\r\nclass Knight extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(isWhite) {\r\n        super(isWhite);\r\n        this.className = (isWhite) ? _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].L_KNIGHT : _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].D_KNIGHT;\r\n    }\r\n\r\n    copy()\r\n    {\r\n        var newPiece = new Knight(this.isWhite);\r\n        this.copyBase(newPiece);\r\n\r\n        return newPiece;\r\n    }\r\n\r\n    getAttackedSquares() {\r\n        var protectedSquares = this.getProtectedSquares();\r\n        var squares = this.removeSquaresWithSameColorPieces(protectedSquares);\r\n\r\n        return squares;\r\n    }\r\n\r\n    getProtectedSquares(){\r\n        var chessboard = this.chessboard;\r\n\r\n        var squares = [];\r\n\r\n        squares.push(chessboard.getSquare(this.row + 2, this.col - 1));\r\n        squares.push(chessboard.getSquare(this.row + 2, this.col + 1));\r\n\r\n        squares.push(chessboard.getSquare(this.row + 1, this.col + 2));\r\n        squares.push(chessboard.getSquare(this.row + 1, this.col - 2));\r\n\r\n        squares.push(chessboard.getSquare(this.row - 1, this.col + 2));\r\n        squares.push(chessboard.getSquare(this.row - 1, this.col - 2));\r\n\r\n        squares.push(chessboard.getSquare(this.row - 2, this.col + 1));\r\n        squares.push(chessboard.getSquare(this.row - 2, this.col - 1));\r\n\r\n        var filtered = [];\r\n\r\n        squares.forEach((e) => {\r\n            if (e) {\r\n                if (e.piece)\r\n                {\r\n\r\n                    //if (e.piece.isWhite != this.isWhite)\r\n                        filtered.push(e);\r\n                }\r\n                else\r\n                {\r\n\r\n                    filtered.push(e);\r\n                }\r\n            }\r\n\r\n        });\r\n        return filtered;\r\n    }\r\n\r\n    getPossibleMoves() {\r\n        return this.getAttackedSquares();\r\n    }\r\n}\n\n//# sourceURL=webpack://chessboard/./src/core/knight.js?");

/***/ }),

/***/ "./src/core/pawn.js":
/*!**************************!*\
  !*** ./src/core/pawn.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pawn)\n/* harmony export */ });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/core/piece.ts\");\n/* harmony import */ var _pieces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieces */ \"./src/core/pieces.js\");\n\r\n\r\n\r\n\r\nclass Pawn extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(isWhite)\r\n    {\r\n        super(isWhite);\r\n        this.direction = (isWhite) ? 1 : -1;\r\n        this.className = (isWhite) ? _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].L_PAWN : _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].D_PAWN;\r\n    }\r\n\r\n    copy()\r\n    {\r\n        var newPiece = new Pawn(this.isWhite);\r\n        this.copyBase(newPiece);\r\n\r\n        return newPiece;\r\n    }\r\n\r\n    getAttackedSquares () {\r\n        var protectedSquares = this.getProtectedSquares();\r\n        var squares = this.removeSquaresWithSameColorPieces(protectedSquares);\r\n\r\n        return squares;\r\n    }\r\n\r\n    getProtectedSquares(){\r\n        var chessboard = this.chessboard;\r\n        var squares = [];\r\n\r\n        if (this.col != undefined && this.row != undefined) {\r\n            squares.push(chessboard.getSquare(this.row + this.direction * 1, this.col + 1));\r\n            squares.push(chessboard.getSquare(this.row + this.direction * 1, this.col - 1));\r\n        }\r\n\r\n        var filtered = [];\r\n\r\n        squares.forEach(function(e){\r\n            if(e)\r\n                filtered.push(e);\r\n        })\r\n\r\n        return filtered;\r\n    }\r\n    \r\n    getPossibleMoves () {\r\n        var chessboard = this.chessboard;\r\n        var attacked = this.getAttackedSquares(chessboard);\r\n        var possible = [];\r\n\r\n        //attacked squares are possible if there is a different color piece\r\n        attacked.forEach(e => {\r\n\r\n            if (e.piece != null && e.piece.isWhite != this.isWhite)\r\n                possible.push(e);\r\n        })\r\n\r\n\r\n        var nextSquare2 = chessboard.getSquare(this.row + (this.direction * 2), this.col);\r\n        var nextSquare = chessboard.getSquare(this.row + (this.direction * 1), this.col);\r\n\r\n\r\n        if (nextSquare.piece == null) {\r\n            possible.push(nextSquare);\r\n\r\n            if (!this.wasMoved && nextSquare2 != null && nextSquare2.piece == null) {\r\n                possible.push(nextSquare2);\r\n            }\r\n        }\r\n\r\n        return possible;\r\n    }\r\n\r\n    isValidMove (dataSquareOrig, dataSquareDest) {\r\n        if (this.canMoveForward(dataSquareOrig, dataSquareDest))\r\n            return true;\r\n\r\n        if (this.canMoveDiagonal(dataSquareOrig, dataSquareDest))\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    canMoveForward (dataSquareOrig, dataSquareDest) {\r\n        /*\r\n            pawn can move forward one square and two squares in the first movement\r\n            only if destiny is a free square \r\n           */\r\n\r\n        if (dataSquareOrig.col == dataSquareDest.col) {\r\n            var increment = this.direction * 1;\r\n            var origRow = dataSquareOrig.row;\r\n            var destRow = dataSquareDest.row;\r\n\r\n            if (origRow + increment == destRow && dataSquareDest.piece == null)\r\n                return true;\r\n\r\n            if (!this.wasMoved && origRow + (2 * increment) == destRow && dataSquareDest.piece == null)\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    canMoveDiagonal (squareOrig, squareDest) {\r\n        var dir = this.direction * 1;\r\n        var isRighDiagonal = squareOrig.col == squareDest.col + 1 && squareOrig.row + dir == squareDest.row;\r\n        var canCapture = squareDest.piece != null && squareDest.piece.isWhite != this.isWhite;\r\n\r\n        if (isRighDiagonal && canCapture)\r\n            return true;\r\n\r\n        var isLeftDiagonal = squareOrig.col = squareDest.col - 1 && squareOrig.row + dir == squareDest.row;\r\n\r\n        if (isLeftDiagonal && canCapture)\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n}\r\n\n\n//# sourceURL=webpack://chessboard/./src/core/pawn.js?");

/***/ }),

/***/ "./src/core/pieces.js":
/*!****************************!*\
  !*** ./src/core/pieces.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\n\r\n let PIECES =\r\n{\r\n    D_BISHOP: \"piece-darkbishop\",\r\n    L_BISHOP: \"piece-lightbishop\",\r\n\r\n    D_QUEEN: \"piece-darkqueen\",\r\n    L_QUEEN: \"piece-lightqueen\",\r\n\r\n    D_KNIGHT: \"piece-darkknight\",\r\n    L_KNIGHT: \"piece-lightknight\",\r\n\r\n    D_KING: \"piece-darkking\",\r\n    L_KING: \"piece-lightking\",\r\n\r\n    D_PAWN: \"piece-darkpawn\",\r\n    L_PAWN: \"piece-lightpawn\",\r\n\r\n    D_ROOK: \"piece-darkrook\",\r\n    L_ROOK: \"piece-lightrook\"\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PIECES);\n\n//# sourceURL=webpack://chessboard/./src/core/pieces.js?");

/***/ }),

/***/ "./src/core/position.js":
/*!******************************!*\
  !*** ./src/core/position.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Position)\n/* harmony export */ });\n/* harmony import */ var _PieceFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PieceFactory */ \"./src/core/PieceFactory.js\");\n\r\n\r\nclass Position\r\n{\r\n    constructor()\r\n    {\r\n\r\n    }\r\n\r\n    setupDefault(chessboard)\r\n    {\r\n        var factory = new _PieceFactory__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n\r\n        var convertCol = {0 : 'a', 1:'b', 2: 'c', 3:'d', 4:'e', 5:'f', 6:'g', 7:'h'}\r\n\r\n        for(var i = 0; i < 8; i++)\r\n        {\r\n            var row = 7;\r\n            var square = convertCol[i] + \"\" + 7;\r\n            var pwn = factory.createDarkPawn();\r\n            chessboard.addPiece(square, pwn);\r\n        }\r\n        \r\n        chessboard.addPiece(\"a8\", factory.createDarkRook());\r\n        chessboard.addPiece(\"b8\", factory.createDarkKight());\r\n        chessboard.addPiece(\"c8\", factory.createDarkBishop());\r\n        chessboard.addPiece(\"d8\", factory.createDarkQueen());\r\n        chessboard.addPiece(\"e8\", factory.createDarkKing());       \r\n        chessboard.addPiece(\"f8\", factory.createDarkBishop());\r\n        chessboard.addPiece(\"g8\",factory.createDarkKight());\r\n        chessboard.addPiece(\"h8\", factory.createDarkRook());\r\n\r\n        for(var i = 0; i < 8; i++)\r\n        {\r\n            var row = 2;\r\n            var square = convertCol[i] + \"\" + 2;\r\n            var pwn = factory.createLightPawn();\r\n            chessboard.addPiece(square, pwn);\r\n        }\r\n\r\n        chessboard.addPiece(\"a1\", factory.createLightRook());\r\n        chessboard.addPiece(\"b1\", factory.createLightKight());\r\n        chessboard.addPiece(\"c1\", factory.createLightBishop());\r\n        chessboard.addPiece(\"d1\", factory.createLightQueen());\r\n        chessboard.addPiece(\"e1\", factory.createLightKing());       \r\n        chessboard.addPiece(\"f1\", factory.createLightBishop());\r\n        chessboard.addPiece(\"g1\",factory.createLightKight());\r\n        chessboard.addPiece(\"h1\", factory.createLightRook());\r\n\r\n    }\r\n\r\n    setupFromFen(fenString, chessboard)\r\n    {\r\n        chessboard.clear();\r\n        var fenSplit = fenString.split(\" \");\r\n        var position = fenSplit[0];\r\n        var turn = fenSplit.length > 1 ? fenSplit[1]: undefined;\r\n\r\n        var ranks = position.split(\"/\");\r\n        var convertCol = {0 : 'a', 1:'b', 2: 'c', 3:'d', 4:'e', 5:'f', 6:'g', 7:'h'};\r\n\r\n        for(let indexRank = 0; indexRank < ranks.length; indexRank++)\r\n        {\r\n            let rank = ranks[7 - indexRank];//fen starts with the last rank\r\n            let col = 0;\r\n\r\n            for(let j = 0; j < rank.length && col < 8; j++)\r\n            {\r\n                let char = rank[j];\r\n                let num = parseInt(char);\r\n                let isNumber = !isNaN(num);\r\n\r\n                if(isNumber)\r\n                {\r\n                    col+=num;\r\n                }\r\n                else\r\n                {\r\n                    let piece = this._CreatePieceFromLetter(char);\r\n                    let position = convertCol[col] + \"\" + (indexRank + 1 );\r\n\r\n                    chessboard.addPiece(position, piece);\r\n                    \r\n                    col++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(turn != undefined){\r\n            if(turn === 'b')\r\n                chessboard.setBlackTurn();\r\n            else if (false)\r\n                {}\r\n        }\r\n    }\r\n\r\n    _CreatePieceFromLetter(letter)\r\n    {\r\n        var factory = new _PieceFactory__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n        if(letter == \"r\")\r\n            return factory.createDarkRook();\r\n        else if(letter == \"n\")\r\n            return factory.createDarkKight();\r\n        else if(letter == \"b\")\r\n            return factory.createDarkBishop();\r\n        else if(letter == \"q\")\r\n            return factory.createDarkQueen();\r\n        else if(letter == \"k\")\r\n            return factory.createDarkKing();\r\n        else if(letter == \"p\")\r\n            return factory.createDarkPawn();\r\n        else if(letter == \"R\")\r\n            return factory.createLightRook();\r\n        else if(letter == \"N\")\r\n            return factory.createLightKight();\r\n        else if(letter == \"B\")\r\n            return factory.createLightBishop();\r\n        else if(letter == \"Q\")\r\n            return factory.createLightQueen();\r\n        else if(letter == \"K\")\r\n            return factory.createLightKing();\r\n        else if(letter == \"P\")\r\n            return factory.createLightPawn();\r\n\r\n        throw new Error(\"unrecognize piece letter \" + letter);\r\n    }\r\n\r\n    _isNumeric(s) {\r\n        return !isNaN(s - parseFloat(s));\r\n    }\r\n}\n\n//# sourceURL=webpack://chessboard/./src/core/position.js?");

/***/ }),

/***/ "./src/core/queen.js":
/*!***************************!*\
  !*** ./src/core/queen.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Queen)\n/* harmony export */ });\n/* harmony import */ var _king__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./king */ \"./src/core/king.js\");\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./piece */ \"./src/core/piece.ts\");\n/* harmony import */ var _pieces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pieces */ \"./src/core/pieces.js\");\n\r\n\r\n\r\n\r\nclass Queen extends _piece__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\r\n    constructor(isWhite) {\r\n        super(isWhite);\r\n        this.className = (isWhite) ? _pieces__WEBPACK_IMPORTED_MODULE_2__[\"default\"].L_QUEEN : _pieces__WEBPACK_IMPORTED_MODULE_2__[\"default\"].D_QUEEN;\r\n    }\r\n\r\n    copy()\r\n    {\r\n        var newPiece = new Queen(this.isWhite);\r\n        this.copyBase(newPiece);\r\n\r\n        return newPiece;\r\n    }\r\n\r\n    getProtectedSquares(){\r\n        var chessboard = this.chessboard;\r\n        var squares = [];\r\n        var maxRow = chessboard.getMaxRow();\r\n        var maxCol = chessboard.getMaxCol();\r\n\r\n        var limit = false;\r\n\r\n        for (var rowi = this.row + 1; rowi <= maxRow && limit == false; rowi++) {\r\n            limit = this.addSquare(rowi, this.col, chessboard, squares);\r\n        }\r\n\r\n        limit = false;\r\n\r\n        for (var rowi = this.row - 1; rowi >= 0 && limit == false; rowi--) {\r\n            limit = this.addSquare(rowi, this.col, chessboard, squares);\r\n        }\r\n\r\n        limit = false;\r\n\r\n\r\n        for (var coli = this.col + 1; coli <= maxCol && limit == false; coli++) {\r\n            limit = this.addSquare(this.row, coli, chessboard, squares);\r\n        }\r\n\r\n        limit = false;\r\n\r\n        for (var coli = this.col - 1; coli >= 0 && limit == false; coli--) {\r\n            limit = this.addSquare(this.row, coli, chessboard, squares);\r\n        }\r\n\r\n\r\n        limit = false;\r\n\r\n        var coli = this.col - 1, rowi = this.row - 1;\r\n\r\n        while (coli >= 0 && rowi >= 0 && limit == false) {\r\n            limit = this.addSquare(rowi, coli, chessboard, squares);\r\n            coli--;\r\n            rowi--;\r\n        }\r\n\r\n        limit = false;\r\n        coli = this.col + 1, rowi = this.row - 1;\r\n\r\n        while (coli <= maxCol && rowi >= 0 && limit == false) {\r\n\r\n            limit = this.addSquare(rowi, coli, chessboard, squares);\r\n            coli++;\r\n            rowi--;\r\n        }\r\n\r\n        limit = false;\r\n\r\n        coli = this.col + 1;\r\n        rowi = this.row + 1;\r\n\r\n        while (coli <= maxCol && rowi <= maxRow && limit == false) {\r\n            limit = this.addSquare(rowi, coli, chessboard, squares);\r\n            coli++;\r\n            rowi++;\r\n        }\r\n\r\n        limit = false;\r\n\r\n        coli = this.col - 1;\r\n        rowi = this.row + 1;\r\n\r\n        while (coli >= 0 && rowi <= maxRow && limit == false) {\r\n            limit = this.addSquare(rowi, coli, chessboard, squares);\r\n            coli--;\r\n            rowi++;\r\n        }\r\n\r\n        return squares;\r\n    }\r\n\r\n    getAttackedSquares() {\r\n        var protectedSquares = this.getProtectedSquares();\r\n        return this.removeSquaresWithSameColorPieces(protectedSquares);\r\n    }\r\n\r\n\r\n    addSquare(row, col, chessboard, squares) {\r\n        var limit = false;\r\n\r\n        var square = chessboard.getSquare(row, col);\r\n\r\n        if (square.piece) {\r\n            limit = true;\r\n\r\n            //if (square.piece.isWhite != this.isWhite){\r\n            //there is a piece of the other color, queen can capture, except the king\r\n            // let isNotKing =!(square.piece instanceof King)\r\n\r\n            // if(isNotKing)\r\n            squares.push(square);\r\n            //}\r\n        }\r\n        else {\r\n            squares.push(square);\r\n        }\r\n\r\n        return limit;\r\n    }\r\n\r\n    getAttackedSquaresLine(targetCol, targetRow) {\r\n        var moves = this.getPossibleMoves();\r\n        var line = []\r\n        for (var i = 0; i < moves.length; i++) {\r\n            var difrows = Math.abs(moves[i].row - targetRow);\r\n            var difcols = Math.abs(moves[i].col - targetCol);\r\n\r\n            var samediagonal = difrows == difcols;\r\n            var samecolOrRow = moves[i].col == targetCol || moves[i].row == targetRow;\r\n\r\n            if (samediagonal || samecolOrRow)\r\n                line.push(moves[i]);\r\n        }\r\n        return line;\r\n    }\r\n\r\n    getPossibleMoves() {\r\n        var attacked = this.getAttackedSquares();\r\n        var posibleSquares = [];\r\n\r\n        for (var i = 0; i < attacked.length; i++) {//filter if the attacked square is the other king\r\n            var square = attacked[i];\r\n            var isOtherKing = square.piece && square.piece.isWhite != this.isWhite && square.piece instanceof _king__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\r\n\r\n            if (!isOtherKing)\r\n                posibleSquares.push(square);\r\n        }\r\n\r\n        return posibleSquares;\r\n    }\r\n\r\n    isSquareOnXRay(row, col){\r\n\r\n        //check diagonals\r\n        if(this._isInLine(col, row, -1, 1 ))\r\n            return true;\r\n\r\n        if(this._isInLine(col, row, 1, 1))\r\n            return true;\r\n\r\n        if(this._isInLine(col, row, 1, -1))\r\n            return true;\r\n\r\n        if(this._isInLine(col, row, -1, -1))\r\n            return true;\r\n\r\n        //check vertical\r\n        if(this._isInLine(col, row, 0, 1))\r\n            return true;\r\n\r\n        if(this._isInLine(col, row, 0, -1))\r\n            return true;\r\n\r\n        //check horizontal\r\n        if(this._isInLine(col, row, 1, 0))\r\n            return true;\r\n\r\n        if(this._isInLine(col, row, -1, 0))\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    _isInLine(x, y, dirX, dirY){\r\n        let isInline = false;\r\n\r\n        let px = this.col + dirX;\r\n        let py = this.row + dirY;\r\n        let maxCol = this.chessboard.getMaxCol();\r\n        let maxRow = this.chessboard.getMaxRow();\r\n\r\n        while(this._isInside(px, py, maxCol, maxRow)){\r\n            if(px == x && py == y)\r\n                return true;\r\n\r\n            px = px + dirX;\r\n            py = py + dirY;\r\n        }\r\n\r\n        return isInline;\r\n    }\r\n\r\n    _isInside(x,y, maxCol, maxRow){\r\n        return x>=0 && y >= 0 && x <= maxCol && y <= maxRow;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://chessboard/./src/core/queen.js?");

/***/ }),

/***/ "./src/core/rook.js":
/*!**************************!*\
  !*** ./src/core/rook.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rook)\n/* harmony export */ });\n/* harmony import */ var _piece__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./piece */ \"./src/core/piece.ts\");\n/* harmony import */ var _pieces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pieces */ \"./src/core/pieces.js\");\n\r\n\r\n\r\n\r\nclass Rook extends _piece__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor(isWhite) {\r\n        super(isWhite);\r\n        this.className = (isWhite) ? _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].L_ROOK : _pieces__WEBPACK_IMPORTED_MODULE_1__[\"default\"].D_ROOK;\r\n    }\r\n\r\n    copy()\r\n    {\r\n        var newPiece = new Rook(this.isWhite);\r\n        this.copyBase(newPiece);\r\n\r\n        return newPiece;\r\n    }\r\n\r\n    getAttackedSquares() {\r\n        var protectedSquares = this.getProtectedSquares();\r\n        var squares = this.removeSquaresWithSameColorPieces(protectedSquares);\r\n\r\n        return squares;\r\n       /* var filterSquaresWithPiecesSameColor = [];\r\n\r\n        for(let i = 0; i < protectedSquares.length; i++){\r\n            let square = protectedSquares[i];\r\n\r\n            if(square.piece){\r\n                if(square.piece.isWhite != this.isWhite){\r\n                    filterSquaresWithPiecesSameColor.push(square);\r\n                }\r\n            }\r\n            else{\r\n                filterSquaresWithPiecesSameColor.push(square);\r\n            }\r\n        }\r\n        \r\n        return filterSquaresWithPiecesSameColor;*/\r\n    }\r\n\r\n    getProtectedSquares(){\r\n        var squares = [];\r\n        var chessboard = this.chessboard;\r\n        var maxc = chessboard.getMaxRow();\r\n        var maxr = chessboard.getMaxCol();\r\n        var limit = false;\r\n\r\n        for (var icol = this.col + 1; icol <= maxc && limit == false; icol++) {\r\n            limit = this.addSquare(this.row, icol, squares);\r\n        }\r\n\r\n        limit = false;\r\n\r\n        for (var icol = this.col - 1; icol >= 0 && limit == false; icol--) {\r\n            limit = this.addSquare(this.row, icol, squares);\r\n        }\r\n\r\n        limit = false;\r\n\r\n        for (var irow = this.row + 1; irow <= maxr && limit == false; irow++) {\r\n            limit = this.addSquare(irow, this.col, squares);\r\n        }\r\n\r\n        limit = false;\r\n\r\n        for (var irow = this.row - 1; irow >= 0 && limit == false; irow--) {\r\n            limit = this.addSquare(irow, this.col, squares);\r\n        }\r\n\r\n        return squares;\r\n    }\r\n\r\n    getPossibleMoves() {\r\n        return this.getAttackedSquares();\r\n    }\r\n\r\n    getAttackedSquaresLine(targetCol, targetRow) {\r\n        var squares = [];\r\n        var moves = this.getPossibleMoves();\r\n\r\n        for (var i = 0; i < moves.length; i++) {\r\n            if (moves[i].col == targetCol || moves[i].row == targetRow)\r\n                squares.push(moves[i]);\r\n        }\r\n\r\n        return squares;\r\n    }\r\n\r\n    addSquare(row, col, squares) {\r\n        var chessboard = this.chessboard;\r\n        var limit = false;\r\n\r\n        var square = chessboard.getSquare(row, col);\r\n\r\n        if (square.piece) {\r\n            limit = true;\r\n\r\n            //if (square.piece.isWhite != this.isWhite)\r\n            squares.push(square);\r\n        }\r\n        else {\r\n            squares.push(square);\r\n        }\r\n\r\n        return limit;\r\n    }\r\n\r\n    //should return true if the square is attacked by the piece, even if there are other pieces in the middle\r\n    isSquareOnXRay(row, col){\r\n      if(this.col == col || this.row == row)\r\n        return true;\r\n      return false;\r\n    }\r\n\r\n\r\n}\r\n\n\n//# sourceURL=webpack://chessboard/./src/core/rook.js?");

/***/ }),

/***/ "./src/core/square.js":
/*!****************************!*\
  !*** ./src/core/square.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Square)\n/* harmony export */ });\n\r\nclass Square {\r\n    piece;\r\n\r\n    constructor()\r\n    {\r\n      this.piece = null;\r\n    }\r\n\r\n    copy()\r\n    {\r\n      var newSquare = new Square();\r\n      \r\n      if(this.piece != null)\r\n        newSquare.piece = this.piece.copy();\r\n\r\n      return newSquare;\r\n    }\r\n  }\r\n  \n\n//# sourceURL=webpack://chessboard/./src/core/square.js?");

/***/ }),

/***/ "./src/core/ui.js":
/*!************************!*\
  !*** ./src/core/ui.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChessboardIU)\n/* harmony export */ });\nfunction ChessboardIU(selector, chessboard)\r\n{\r\n    var self = this;\r\n    this.container = selector;\r\n    this.elem = null;\r\n    this.chessboard = chessboard;\r\n    this.dragPieces = null;\r\n    \r\n    this.pickedPiece = null;\r\n    this.originPickedPiece = null;\r\n\r\n   this.draw = function(chessboard)\r\n    {\r\n        var chessboard = this.chessboard;\r\n          var squares = document.querySelectorAll(this.container + \" .row .square\");\r\n\r\n         for(var i = 0; i < squares.length; i++ )\r\n         {\r\n         \r\n                var domSquare = squares[i];\r\n                var col = i % 8; \r\n                var row = parseInt( i / 8);\r\n                \r\n                var r = chessboard.squares[7 - row];\r\n                var sq = r[col];\r\n\r\n                if(sq.piece == null)\r\n                {\r\n                    domSquare.innerHTML = \"\";\r\n                }\r\n                else\r\n                {\r\n                    var className = \"piece \" + sq.piece.className;\r\n                    domSquare.innerHTML = \"<div class='\" + className + \"'> </div>\";\r\n                }\r\n\r\n         }\r\n    }\r\n\r\n\r\n   \r\n    this._init = function()\r\n    {\r\n        this.dragPieces = new DraggPieces(this.container);\r\n        this.dragPieces.OnDropPiece = OnDroppedPiece;\r\n        this.dragPieces.OnPickPiece = OnPickPiece;\r\n    }\r\n\r\n    this._drawAttacked = function(squares)\r\n    {\r\n\r\n        squares.forEach(s => {\r\n          var elem = self._getSquare(s.col, s.row);\r\n          \r\n          if(elem)\r\n          {\r\n              elem.className += \" attacked\";\r\n          }\r\n          \r\n        });\r\n    }\r\n\r\n    this._drawUnattacked = function()\r\n    {\r\n        var squares = document.querySelectorAll(this.container + \" .row .square\");\r\n\r\n        for(var i = 0; i < squares.length; i++)\r\n        {\r\n            var square = squares[i];\r\n\r\n            var index = square.className.indexOf(\"attacked\");\r\n            \r\n            if(index > -1)\r\n            {\r\n                var firstPart =  square.className.substring(0, index );\r\n                var secondPart =  square.className.substring(index + 8, square.className.length );\r\n\r\n                square.className = firstPart + \" \" + secondPart;\r\n\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n\r\n    this._getSquare = function(col, row)\r\n    {\r\n        var id = self.chessboard.convertPositionToString(col, row);\r\n        var squareElem = null;\r\n        \r\n        if(id)\r\n        {\r\n            squareElem = document.getElementById(id);\r\n        }\r\n        \r\n        return squareElem;\r\n    }\r\n    \r\n    var OnDroppedPiece = function( square)\r\n    {\r\n        var clone = self.pickedPiece.cloneNode(true);\r\n        \r\n        if(square == null)//if the piece wasn't dropped on a square, move the piece to the original square\r\n        {\r\n            self.originPickedPiece.appendChild(clone);\r\n        }\r\n        else{\r\n        \r\n            var originSquareString = getSquareString(self.originPickedPiece);\r\n            var destinySquareString = getSquareString(square);\r\n\r\n            if(self.chessboard.isValidMove(originSquareString, destinySquareString))\r\n            {\r\n                if(square.children.length > 0)\r\n                    square.removeChild(square.children[0]);\r\n                    \r\n                square.appendChild(clone);\r\n                    \r\n                self.chessboard.move(originSquareString, destinySquareString);\r\n\r\n                if(self.chessboard.isCheckMate())\r\n                    window.alert(\"Check mate\");\r\n\r\n                self.draw();\r\n            }\r\n            else\r\n            {\r\n                self.originPickedPiece.appendChild(clone);\r\n            }\r\n        }\r\n\r\n        self._drawUnattacked();\r\n        \r\n       self.pickedPiece.remove();\r\n       self.pickedPiece = null;\r\n       self.originPickedPiece = null;\r\n    }\r\n    \r\n    var OnPickPiece = function(pickecPiece, originSquare )\r\n    {\r\n        var originSquareString = getSquareString(originSquare);\r\n        \r\n        var piece = self.chessboard.getPiece(originSquareString);\r\n        \r\n        if(piece != null)\r\n        {\r\n            var squares = piece.getPossibleMoves(self.chessboard);\r\n            self._drawAttacked(squares);\r\n        }\r\n\r\n\r\n        self.originPickedPiece = originSquare;\r\n        self.pickedPiece = pickecPiece.cloneNode(true);\r\n        pickecPiece.remove();\r\n    }\r\n\r\n    var getSquareString = function(square)\r\n    {\r\n        return square.id;\r\n    }\r\n\r\n    this._init();\r\n    \r\n}\r\n\r\nfunction DraggPieces(container)\r\n{\r\n    this.OnPickPiece = null;\r\n    this.OnDropPiece = null;\r\n    this.container = container;\r\n    this.elem = null;\r\n\r\n    var draggingElement = null;\r\n    var isMouseDown = false;\r\n    var squareOrigin = null;\r\n    var self = this;\r\n    \r\n    var mouseX = 0;\r\n    var mouseY = 0;\r\n\r\n    this._init = function()\r\n    {\r\n        this.elem = document.querySelectorAll(this.container);\r\n        var squares = document.querySelectorAll(this.container + \" .row .square\");\r\n        \r\n        for(var i = 0; i < squares.length; i++)\r\n        {\r\n            var domSquare = squares[i];\r\n\r\n            \r\n            domSquare.addEventListener(\"mousedown\", this._mouseDown, true);\r\n            domSquare.addEventListener(\"mouseup\", this._mouseUp, true);\r\n        }\r\n        \r\n        document.body.addEventListener(\"mouseup\", this._mouseUp, false);\r\n    }\r\n\r\n   \r\n    this._mouseDown = function(e)\r\n    {\r\n        //prevents the on drag start event, avoiding clonflics\r\n        e.preventDefault();\r\n        var square = this;\r\n        var piece = square.querySelector(\".piece\");\r\n\r\n        if(piece != null)\r\n        {\r\n            squareOrigin = square;\r\n            \r\n            mouseX = e.clientX;\r\n            mouseY = e.clientY;\r\n            \r\n            isMouseDown = true;\r\n            var rect = piece.getBoundingClientRect();\r\n            \r\n            draggingElement = piece.cloneNode(true);\r\n            draggingElement.className += \" dragging\";\r\n            draggingElement.style.top = rect.y + \"px\";\r\n            draggingElement.style.left = rect.x + \"px\";\r\n\r\n            document.body.appendChild(draggingElement);\r\n           \r\n            document.body.addEventListener(\"mousemove\", self._mouseMove, false);\r\n\r\n            if(self.OnPickPiece instanceof Function)\r\n                self.OnPickPiece(piece, squareOrigin);\r\n\r\n        } \r\n    }\r\n    \r\n    this._mouseMove = function(e)\r\n    {\r\n        if(!isMouseDown)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var deltaX = e.clientX - mouseX;\r\n        var deltaY = e.clientY - mouseY;\r\n        \r\n        var rect = draggingElement.getBoundingClientRect();\r\n\r\n        var newX = rect.x + deltaX;\r\n        var newY = rect.y + deltaY;\r\n\r\n        draggingElement.style.top = newY + \"px\";\r\n        draggingElement.style.left = newX + \"px\";\r\n\r\n        mouseX = e.clientX;\r\n        mouseY = e.clientY;\r\n    }\r\n    \r\n    this._mouseUp = function(e)\r\n    {\r\n        if(!isMouseDown)\r\n            return;\r\n        \r\n        //first stop the move event\r\n      \r\n        isMouseDown = false;\r\n\r\n        //verify if the pieces was dropped in the a square\r\n        var classTarget = e.currentTarget.className;\r\n        var squareDestiny = null;\r\n\r\n        if(classTarget != null && classTarget.includes(\"square\"))\r\n        {\r\n            squareDestiny = e.currentTarget;\r\n        }\r\n       \r\n        \r\n        var clone = draggingElement.cloneNode(true);\r\n        \r\n        clone.className = clone.className.replace(\"dragging\", \"\");\r\n        clone.style.top = '';\r\n        clone.style.left = '';\r\n            \r\n           \r\n        draggingElement.remove();\r\n        document.body.removeEventListener(\"mousemove\", self._mouseMove, false);\r\n        draggingElement = null;\r\n        squareOrigin = null;\r\n        \r\n        if(self.OnDropPiece instanceof Function)\r\n        {\r\n            self.OnDropPiece(squareDestiny);\r\n        }\r\n    }\r\n    \r\n    this._init();\r\n}\r\n\n\n//# sourceURL=webpack://chessboard/./src/core/ui.js?");

/***/ }),

/***/ "./src/mate/annotations.js":
/*!*********************************!*\
  !*** ./src/mate/annotations.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Annotations)\n/* harmony export */ });\nclass Annotations{\r\n    id;\r\n    classList;\r\n    moves;\r\n    chessboard;\r\n    indexMove;\r\n\r\n    constructor(){\r\n        this.id = \".annotations\";\r\n        this.nextButtonId = \".nextButton\";\r\n        this.previousButtonId = \".previousButton\";\r\n        this.classList = \".moves\"\r\n        this.moves = [\r\n            {white: \"Bxf7+\", black: \"Txf7\"},\r\n            {white: \"Cxf7\", black: \"Kxf7\"},\r\n            {white: \"Cg5+\", black: null},\r\n        ];\r\n\r\n        this.currentMove = {index: -1, color: \"white\"}\r\n\r\n        var prevBtn = document.querySelector(this.previousButtonId);\r\n        var nextBtn = document.querySelector(this.nextButtonId);\r\n\r\n        prevBtn.addEventListener(\"click\", () => this.onClickPreviousButton());\r\n        nextBtn.addEventListener(\"click\", () => this.onClickNextButton());\r\n    }\r\n\r\n    onClickPreviousButton(){\r\n        console.log(\"previous button\");\r\n    }\r\n\r\n    onClickNextButton(){\r\n        if(this.currentMove.color == \"black\" && (this.currentMove.index + 1) >= this.moves.length)\r\n            return;\r\n\r\n        let {index, color} = this.currentMove;\r\n\r\n        if(index >= 0){\r\n            //remove class of previous move\r\n            let currentMove = this.getMoveInDom(index, color);\r\n            currentMove.className = currentMove.className.replace(\"current\", \"\");\r\n        }\r\n      \r\n        //update current to next data\r\n        if(index < 0){\r\n            this.currentMove.index = 0;\r\n            this.currentMove.color = \"white\";\r\n        }else{\r\n            if (color == \"white\") {\r\n                this.currentMove.color = \"black\";\r\n            }\r\n            else {\r\n                this.currentMove.index += 1;\r\n                this.currentMove.color = \"white\";\r\n            }\r\n        }\r\n\r\n        //update class of current move\r\n        let nextMove = this.getMoveInDom(this.currentMove.index, this.currentMove.color);\r\n        nextMove.className += \" current\";\r\n    }\r\n\r\n    getMoveInDom(index, color) {\r\n        var cls = \".move_\" + index + \".\" + color;\r\n        var current = document.querySelector(cls);\r\n\r\n        return current;\r\n    }\r\n\r\n    draw() {\r\n        let newHtml = \"\";\r\n\r\n        for (let i = 0; i < this.moves.length; i++) {\r\n            let move = this.moves[i];\r\n\r\n            let moveclasswhite = \"move \" + \"move_\" + i +  \" white\";\r\n            let moveclassblack = \"move \" + \"move_\" + i + \" black\";\r\n\r\n            let whiteMove = \"<span class='\" + moveclasswhite + \"'>\" + (move.white ?? \"\") + \"</span>\";\r\n            let blackMove = \"<span class='\" + moveclassblack + \"'>\" + (move.black ?? \"\") + \"</span>\"\r\n            newHtml += \"<li> \" + whiteMove + \",  \" + blackMove + \"</li>\"\r\n        }\r\n\r\n        var element = document.querySelector(this.id + \" \" + this.classList);\r\n        element.innerHTML = newHtml;\r\n    }\r\n}\n\n//# sourceURL=webpack://chessboard/./src/mate/annotations.js?");

/***/ }),

/***/ "./src/mate/mate.js":
/*!**************************!*\
  !*** ./src/mate/mate.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/board */ \"./src/core/board.js\");\n/* harmony import */ var _core_computer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/computer */ \"./src/core/computer.js\");\n/* harmony import */ var _core_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/position */ \"./src/core/position.js\");\n/* harmony import */ var _annotations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./annotations */ \"./src/mate/annotations.js\");\n/* harmony import */ var _core_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/ui */ \"./src/core/ui.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n(function(){\r\n\r\n    var chessboard = null;\r\n    var ui = null;\r\n    var submitFenId = \"fen-submit\";\r\n    var textAreaFen = \"fen-textarea\";\r\n    var nextMoveButtonId = \"next-move\";\r\n    var checkMateButtonId = \"find-checkmate\";\r\n    var defaultFen = \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\r\n    var mateFen = \"8/8/8/2Q5/8/r7/k1K5/8 w - - 0 1\";\r\n\r\n    var movesFound = [];\r\n    var currentMoveIndex = -1;\r\n\r\n    var annotations = new _annotations__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\r\n\r\n    var init =  function()\r\n    {\r\n        initHandlers();\r\n\r\n        chessboard = new _core_board__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n        ui = new _core_ui__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\".chessboard\", chessboard);\r\n\r\n        let position = new _core_position__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\r\n        position.setupFromFen(mateFen, chessboard);\r\n\r\n        ui.draw();\r\n        annotations.draw();\r\n    }\r\n\r\n    var initHandlers = function()\r\n    {\r\n        var submitFen = document.getElementById(submitFenId);\r\n        submitFen.addEventListener(\"click\", onSetupFen, false);\r\n\r\n        var checkMateButton = document.getElementById(checkMateButtonId);\r\n        checkMateButton.addEventListener(\"click\", findCheckMate);\r\n\r\n        var nextMoveButton =  document.getElementById(nextMoveButtonId);\r\n        nextMoveButton.addEventListener(\"click\", nextMove);\r\n    }\r\n\r\n    var onSetupFen = function(e)\r\n    {\r\n        e.preventDefault();\r\n        var textArea = document.getElementById(textAreaFen);\r\n        var txt = textArea.value;\r\n\r\n        let position = new _core_position__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\r\n        position.setupFromFen(txt, chessboard);\r\n        ui.draw();\r\n    }\r\n\r\n    var findCheckMate = function(){\r\n        var checkmate = new _core_computer__WEBPACK_IMPORTED_MODULE_1__.CheckMate();\r\n        var solution = checkmate.search(chessboard);\r\n\r\n        if(solution != null){\r\n            console.log(solution);\r\n            movesFound = solution;\r\n            currentMoveIndex = 0;\r\n        }\r\n        else{\r\n            alert(\"check mate not found\");\r\n        }\r\n\r\n        console.log(\"find checkmate\");\r\n    }\r\n\r\n    var nextMove = function(){\r\n        if(movesFound.length == 0)\r\n            return;\r\n\r\n        var move = movesFound[currentMoveIndex];\r\n\r\n        if(move){\r\n            chessboard.move(move.squareFrom, move.squareTo);\r\n            currentMoveIndex++;\r\n\r\n            ui.draw();\r\n        }\r\n\r\n    }\r\n\r\n    window.onload  = init;\r\n})();\n\n//# sourceURL=webpack://chessboard/./src/mate/mate.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/mate/mate.js");
/******/ 	
/******/ })()
;